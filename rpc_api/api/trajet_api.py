# coding: utf-8

"""
    API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 3.0
    Contact: technique@covoiturage.beta.gouv.fr
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rpc_api.api_client import ApiClient


class TrajetApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def acquisition_cancel(self, operator_journey_id, **kwargs):  # noqa: E501
        """Invalider un trajet envoyé  # noqa: E501

        Annule un trajet déjà envoyé dans le registre. S'il détecte un comportement inhabituel ou une fraude avérée, un opérateur doit communiquer auprès du service l'invalidation du trajet concerné dès lors qu'il est déjà inscrit dans le registre.  Cette invalidation doit avoir lieu dès que l'opérateur a connaissance de cette irrégularité à tout moment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_cancel(operator_journey_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OperatorJourneyId operator_journey_id: operator_journey_id of the journey created (required)
        :param OperatorJourneyIdCancelBody body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.acquisition_cancel_with_http_info(operator_journey_id, **kwargs)  # noqa: E501
        else:
            (data) = self.acquisition_cancel_with_http_info(operator_journey_id, **kwargs)  # noqa: E501
            return data

    def acquisition_cancel_with_http_info(self, operator_journey_id, **kwargs):  # noqa: E501
        """Invalider un trajet envoyé  # noqa: E501

        Annule un trajet déjà envoyé dans le registre. S'il détecte un comportement inhabituel ou une fraude avérée, un opérateur doit communiquer auprès du service l'invalidation du trajet concerné dès lors qu'il est déjà inscrit dans le registre.  Cette invalidation doit avoir lieu dès que l'opérateur a connaissance de cette irrégularité à tout moment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_cancel_with_http_info(operator_journey_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OperatorJourneyId operator_journey_id: operator_journey_id of the journey created (required)
        :param OperatorJourneyIdCancelBody body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operator_journey_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method acquisition_cancel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'operator_journey_id' is set
        if ('operator_journey_id' not in params or
                params['operator_journey_id'] is None):
            raise ValueError("Missing the required parameter `operator_journey_id` when calling `acquisition_cancel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operator_journey_id' in params:
            path_params['operator_journey_id'] = params['operator_journey_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['token']  # noqa: E501

        return self.api_client.call_api(
            '/journeys/{operator_journey_id}/cancel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def acquisition_create(self, body, **kwargs):  # noqa: E501
        """Envoyer un trajet  # noqa: E501

        Un trajet est un couple passager.ère / conducteur.rice ayant des points et de horaires de départ et d'arrivée. Si une conductrice covoiture avec plusieurs passagères, plusieurs trajets sont déclarés.  ### Unités de mesure  Les unités utilisées pour les valeurs sont :  - montants financiers en **centimes d'Euros** - distances en **mètres**  ### Données financières  Le principe est de coller au plus près avec la réalité comptable \\(transaction usager\\) et d'avoir suffisamment d'informations pour recalculer le coût initial du trajet. Ainsi, les propriétés `passenger.contribution` et `driver.revenue` combinées au tableau `incentives` doivent permettre ce calcul. Ceci afin de s'assurer du respect de la définition du covoiturage et de la bonne application des politiques incitatives gérées par le registre. > Les données envoyées en `passenger.contribution` et `driver.revenue` sont utilisées dans les attestations de covoiturage à destination des employeurs (Forfait Mobilités Durables).  ### Validation Le schéma de données est présenté au format [JSON Schema Draft-07](https://json-schema.org/understanding-json-schema/index.html).  ### Vérification Dans le cadre de la fraude inter opérateurs, les opérateurs sont tenus de vérifier le statut du trajet au plus tôt 24h après la réalisation de celui-ci. Ces trajets seront retournés avec un champs `status` à `fraud_error` et un label dans `fraud_error_labels` à `interoperator_fraud`. Le statut ne peut plus changer 48h après la date de fin du trajet.  En cas d'indisponibilité du service, le trajet est considéré comme `ok` après 48h L'algorithme de détection de fraude inter opérateurs est appliqué sur tous les trajets envoyés.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_create(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param JourneysBody body: (required)
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.acquisition_create_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.acquisition_create_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def acquisition_create_with_http_info(self, body, **kwargs):  # noqa: E501
        """Envoyer un trajet  # noqa: E501

        Un trajet est un couple passager.ère / conducteur.rice ayant des points et de horaires de départ et d'arrivée. Si une conductrice covoiture avec plusieurs passagères, plusieurs trajets sont déclarés.  ### Unités de mesure  Les unités utilisées pour les valeurs sont :  - montants financiers en **centimes d'Euros** - distances en **mètres**  ### Données financières  Le principe est de coller au plus près avec la réalité comptable \\(transaction usager\\) et d'avoir suffisamment d'informations pour recalculer le coût initial du trajet. Ainsi, les propriétés `passenger.contribution` et `driver.revenue` combinées au tableau `incentives` doivent permettre ce calcul. Ceci afin de s'assurer du respect de la définition du covoiturage et de la bonne application des politiques incitatives gérées par le registre. > Les données envoyées en `passenger.contribution` et `driver.revenue` sont utilisées dans les attestations de covoiturage à destination des employeurs (Forfait Mobilités Durables).  ### Validation Le schéma de données est présenté au format [JSON Schema Draft-07](https://json-schema.org/understanding-json-schema/index.html).  ### Vérification Dans le cadre de la fraude inter opérateurs, les opérateurs sont tenus de vérifier le statut du trajet au plus tôt 24h après la réalisation de celui-ci. Ces trajets seront retournés avec un champs `status` à `fraud_error` et un label dans `fraud_error_labels` à `interoperator_fraud`. Le statut ne peut plus changer 48h après la date de fin du trajet.  En cas d'indisponibilité du service, le trajet est considéré comme `ok` après 48h L'algorithme de détection de fraude inter opérateurs est appliqué sur tous les trajets envoyés.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_create_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param JourneysBody body: (required)
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method acquisition_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `acquisition_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['token']  # noqa: E501

        return self.api_client.call_api(
            '/journeys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def acquisition_status(self, operator_journey_id, **kwargs):  # noqa: E501
        """Vérifier le statut d'un trajet envoyé  # noqa: E501

        Lors de l'envoi d'un trajet, un code 201 et un payload avec le `operator_journey_id` et la date de création vous sont renvoyés. Le trajet est alors enregistré dans notre base. Le processus de validation par lequel vont passer les données est complexe, asynchrone et dépend de différents services ayant de temps de réponse variables. Les trajets ne seront visibles dans l'interface utilisateurs que **24 heures** après leur envoi.  Il est possible de vérifier le statut d'un trajet envoyé directement pour s'assurer qu'il n'y pas pas eu d'erreur de format ou de traitement.  Dans le cadre de la fraude inter opérateurs, les opérateurs sont tenus de vérifier le statut du trajet au plus tôt 24h après la réalisation de celui-ci. Un trajet detecté sera retourné avec un champ `status` à `fraud_error`. Le statut ne peut plus changer 48h après la date de fin du trajet. En cas d'indisponibilité du service, le trajet est considéré comme ok après les 48h  L'algorithme de détection de fraude inter opérateurs est appliqué sur tous les trajets envoyés.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_status(operator_journey_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OperatorJourneyId operator_journey_id: operator_journey_id of the journey created (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.acquisition_status_with_http_info(operator_journey_id, **kwargs)  # noqa: E501
        else:
            (data) = self.acquisition_status_with_http_info(operator_journey_id, **kwargs)  # noqa: E501
            return data

    def acquisition_status_with_http_info(self, operator_journey_id, **kwargs):  # noqa: E501
        """Vérifier le statut d'un trajet envoyé  # noqa: E501

        Lors de l'envoi d'un trajet, un code 201 et un payload avec le `operator_journey_id` et la date de création vous sont renvoyés. Le trajet est alors enregistré dans notre base. Le processus de validation par lequel vont passer les données est complexe, asynchrone et dépend de différents services ayant de temps de réponse variables. Les trajets ne seront visibles dans l'interface utilisateurs que **24 heures** après leur envoi.  Il est possible de vérifier le statut d'un trajet envoyé directement pour s'assurer qu'il n'y pas pas eu d'erreur de format ou de traitement.  Dans le cadre de la fraude inter opérateurs, les opérateurs sont tenus de vérifier le statut du trajet au plus tôt 24h après la réalisation de celui-ci. Un trajet detecté sera retourné avec un champ `status` à `fraud_error`. Le statut ne peut plus changer 48h après la date de fin du trajet. En cas d'indisponibilité du service, le trajet est considéré comme ok après les 48h  L'algorithme de détection de fraude inter opérateurs est appliqué sur tous les trajets envoyés.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_status_with_http_info(operator_journey_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OperatorJourneyId operator_journey_id: operator_journey_id of the journey created (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operator_journey_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method acquisition_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'operator_journey_id' is set
        if ('operator_journey_id' not in params or
                params['operator_journey_id'] is None):
            raise ValueError("Missing the required parameter `operator_journey_id` when calling `acquisition_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operator_journey_id' in params:
            path_params['operator_journey_id'] = params['operator_journey_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['token']  # noqa: E501

        return self.api_client.call_api(
            '/journeys/{operator_journey_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def acquisition_update(self, body, operator_journey_id, **kwargs):  # noqa: E501
        """Mettre à jour un trajet  # noqa: E501

        Permet de mettre à jour un trajet qui est en erreur suite à un problème de validation sur le payload. Par exemple suite à un problème de validation sur les coordonnées géographiques envoyées   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_update(body, operator_journey_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param JourneysOperatorJourneyIdBody body: (required)
        :param OperatorJourneyId operator_journey_id: operator_journey_id of the journey created (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.acquisition_update_with_http_info(body, operator_journey_id, **kwargs)  # noqa: E501
        else:
            (data) = self.acquisition_update_with_http_info(body, operator_journey_id, **kwargs)  # noqa: E501
            return data

    def acquisition_update_with_http_info(self, body, operator_journey_id, **kwargs):  # noqa: E501
        """Mettre à jour un trajet  # noqa: E501

        Permet de mettre à jour un trajet qui est en erreur suite à un problème de validation sur le payload. Par exemple suite à un problème de validation sur les coordonnées géographiques envoyées   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.acquisition_update_with_http_info(body, operator_journey_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param JourneysOperatorJourneyIdBody body: (required)
        :param OperatorJourneyId operator_journey_id: operator_journey_id of the journey created (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'operator_journey_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method acquisition_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `acquisition_update`")  # noqa: E501
        # verify the required parameter 'operator_journey_id' is set
        if ('operator_journey_id' not in params or
                params['operator_journey_id'] is None):
            raise ValueError("Missing the required parameter `operator_journey_id` when calling `acquisition_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operator_journey_id' in params:
            path_params['operator_journey_id'] = params['operator_journey_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['token']  # noqa: E501

        return self.api_client.call_api(
            '/journeys/{operator_journey_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def journeys_get(self, status, **kwargs):  # noqa: E501
        """Liste des trajets  # noqa: E501

        La liste est toujours ordonnée de manière antechronologique. Les trajets apparaissent au plus tard 24h après leur envoi. Dans le cadre de la fraude inter-opérateurs, les opérateurs sont tenus de vérifier le statut du trajet au plus tôt 48h après la réalisation de celui-ci. Ces trajets peuvent être listés en passant un paramètre `status` à `fraud_error`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.journeys_get(status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Status status: Statut du trajet (required)
        :param Limit limit: Limite, par défaut 50.
        :param ModelDatetime start: Date de début de recherche, par défaut dans la semaine qui précède.
        :param ModelDatetime end: Date de fin de recherche, par défaut le jour même.
        :param Offset offset: Offset, par défaut 0.
        :return: list[InlineResponse2002]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.journeys_get_with_http_info(status, **kwargs)  # noqa: E501
        else:
            (data) = self.journeys_get_with_http_info(status, **kwargs)  # noqa: E501
            return data

    def journeys_get_with_http_info(self, status, **kwargs):  # noqa: E501
        """Liste des trajets  # noqa: E501

        La liste est toujours ordonnée de manière antechronologique. Les trajets apparaissent au plus tard 24h après leur envoi. Dans le cadre de la fraude inter-opérateurs, les opérateurs sont tenus de vérifier le statut du trajet au plus tôt 48h après la réalisation de celui-ci. Ces trajets peuvent être listés en passant un paramètre `status` à `fraud_error`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.journeys_get_with_http_info(status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Status status: Statut du trajet (required)
        :param Limit limit: Limite, par défaut 50.
        :param ModelDatetime start: Date de début de recherche, par défaut dans la semaine qui précède.
        :param ModelDatetime end: Date de fin de recherche, par défaut le jour même.
        :param Offset offset: Offset, par défaut 0.
        :return: list[InlineResponse2002]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'limit', 'start', 'end', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method journeys_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'status' is set
        if ('status' not in params or
                params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `journeys_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/journeys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2002]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
